# 第三周 浮点数、RISC-V 入门

## 6.1 Basics & Fixed Point

有 6 个 bits 用来表示浮点数，且规定二进制的小数点在从左往右的第二位，二进制 0 表示为即 `00.0000`。
而 `11.1111` 表示十进制的 3.9375 (3+15/16)。

那么 6 bits 能表示的小数范围为 `[0 - 3.9375]`。如果不规定这个小数点，6 bits 能表示的无符号整数范围为 `[0-63]`。

上述表示小数的前提是，要实现规定二进制的小数点在某个位置。那么能否在给定一个二进制数的同时，再传入一个小数点的位数，来确定它对应的小数大小？这样小数点就不是 fixed，而是 floating。

## 6.2 - Floating Point: Floating Point

假设要把 0.1640625 以二进制表示，用 5个bits 表示其 energy，再选择把二进制小数点放在哪里。

`...000000.001010100000...`

浮点数存的是 `10101` 这个 energy 部分，以及二进制小数点的位置：位于 energy 的 MSB 左边的两位。

在浮点数表示下，每个数都带一个 exponent 字段来记录它的二进制小数点放在哪里。类似十进制，当一个数乘以 10 的1次，小数点右移1位，右边补个0，这个数变为10倍；乘以10^(-2)，小数点左移两位，左边要补两个0，这个数缩小了100倍。

只不过 exponent 是基于 2 进行扩大缩小，小数点右移1位，整个数变为2倍；左移1位，变为 1/2。

浮点数的标准格式：`+1.xxx...x * 2^(yyy...y)`，注意，二进制小数点左边的永远都是 1。

其中，`+` 是符号位， `xxx...x` 小数点部分叫 significand(有效数), `yyy...y` 指数部分就是 exponent。由于小数点左边永远是1，这是约定所以不用保存这个1。用一个 32 位的 word size 保存一个浮点数：
  - 符号位占1位，最左边的那位
  - exponent占8位，符号位的后8位
  - significand占23位，符号位后的23位。

注，浮点数中的符号位用的是 `sign magnitude` 表示，0表示整个浮点数是正数，1表示负数。不是整型用的2补数表示。

不看指数的情况下, 有效数表示的数值是：
  - `100000...0`: 1后面全部零，表示二进制的 `1.100000...0`，表示十进制的 1.5
  - `00000...1`: 前面全是0，最后一位是1，表示二进制的 `1.00000...1`，表示十进制的 `1+2^(-23)`
即在标准的科学计数法下，单独的有效数永远 >0 且 <1，在算数值的时候要把省略的1加上去。如果有效数全是0，表示整个数是0

8 位exponent也有正负表示，IEEE 754 用的是`biased notation` 表示法，单精度的 bias 是127，即8位能表示的数([0,255])减去127，得到最终的取值范围[-127,...0...,128]。具体算法是：

`(-1)^s × (1 + significand) × 2^(exponent-127)`, s 是符号位，要么1，要么0

双精度浮点数的算法相同，只不过它的 bias 是 1023

溢出问题：
  - 对于 >3.4×10^38, <-3.4×10^38 的数，就会溢出8位的exponent，即大于两端的值会出现溢出
  - 对于 >0 且 <1.2×10^(-38), <0 且 > -1.2×10^(-38) 的，也会溢出8位的exponent，即无限接近0的值也会有溢出

能否解决溢出问题？无法从根本解决，但可以减少，比如提高 significand 的位数，从单精度的 1+23bits 提高到双精度的 1+52bits。

## 6.3 - Floating Point: Special Numbers

浮点数表示概括来说，保存一个 significand 作为有效数，保存一个 exponent，在有效数的基础上 ×2 或者 ÷2，保存符号位区分正负，通过计算公式：`(-1)^s × (1 + significand) × 2^(exponent-127)`，得到最终结果。

实际上有效数和指数有如下几种组合类型：

| exponent | significand | Object  | 
|---|---|---|
| 0 | 0 | 0 |
| 0 |  非零值 | 非标准科学计数值 |
| 1-254 | 任何值 | 正常的正负浮点数值 |
| 255 | 0 | 正负无穷 |
| 255 | 非零值 | NaN |

上面提到的计算公式，适用于第三行的浮点数计算。

正负无穷数的表示：IEEE 754 中，只要越过边界，就得到正负无穷的值。
非数（NaN）的表示：非数指进行 sqrt(-4) 、0/0 等运算得到的结果，在数学上是错误，在计算机中是非数。IEEE 把指数为 255，有效数为非零数的组合，用来表示非数。用这个组合表示的好处是，不管与 NaN 参与多少次运算，结果都是 NaN，且不产生错误。用一个公式表达是： `op(NaN, X) = NaN`。并且由于有效数非零的情况有 2^23 次种（单精度），也就是有 2^23 中 NaN 的情况，因此可以根据有效数的 bit pattern 确定一些 NaN 错误的分类，如这是除以0 产生的NaN，这是给复数开根号产的等等。

Gap around 0: 在整数的表示法中，0 到下一个数 1 的距离是1, 1 到 下一个数 2 的距离也是 1。在浮点数中不是这样。
  - 浮点数中最小的正数a：（1.000...0）* 2^(1-127) = 2^(-126)
  - 浮点数中第二小的正数b: (1.000...1) * 2^(1-127) = (1 + 2^(-23)) * 2^(-126) = 2^(-126) + 2^(-149)

0 到 a 的差距：2^(-126);
a 到 b 的差距：2^(-149), 可见但 0 到第一个正数的差距是后续间隔的 2^23 倍。

这是因为标准科学计数法(normalization)的规定带来的副作用，从 0 一下子到了 1 点多，之间有 2^23 个数不能用当前的科学计数法表示。为了表示这些数，我们希望为这段 gap 去标准化(denormalize, 不用科学计数法的规定)，这时就用到指数为 0，有效数非零的组合。在这个比特组合下的数，有效数不再加上默认的 1，指数全为0，算作 2^(-126)。加上去标准化计数后，再来算
  - 最小值a为：2^(-126) * 2^(-23) = 2^(-149)
  - 第二小值b为：2^(-126) * 2^(-22) = 2^(-148)，两者之间的差距是 2^(-149)，和后面从 1 之后的科学计数的间隔相同。

指数部分是告诉有效数怎么递增， ...1/4, 1/2, 1, 2, 4...，越到后面，间隔越大。

## 6.4 - Floating Point: Examples, Discussion

几个浮点数转整数的例子：

- `1 | 1000 0001 | 111 0000 0000 0000 0000 0000`，| 只是用来在视觉上隔开符号位、指数位和有效数位的，使得浮点数的各部分更好辨认，无实际意义。
  - 指数在 1-254 之间，是正常的浮点数，按照公式计算。符号为1是负数，指数是2(129-127)，有效数(1+ .111)<sub>2</sub>
  - = -1 * (1.111)<sub>2</sub> * 2^2
  - = -111.1<sub>2</sub>
  - = -7.5<sub>10</sub>

- 用浮点数表示十进制数 `1/3`，即 0.33333...<sub>10</sub>，算法是，用二进制的小数位的值去"凑"，1/3 是几个 0.5 + 几个 0.25 + 几个 0.125 + 几个 0.0625 +...+ 几个 2^(-23)
  - 就 1/3 来说，其规律是 2^(-2) + 2^(-4) + 2^(-8) + ...
  - = 0.01010101...<sub>2</sub> * 2^0
  - = 1.010101...<sub>2</sub> * 2^(-2)，为什么这里变 -2 了? 因为从浮点数计算十进制数时，默认小数点前是有1的，所以这里要表示成有1的形式，相当于把上面值的小数点向右移动了两位得到，为了保证数值相等，下面的就要左移两位，即乘以 2^(-2)，（疑问，其他小数加上1后，也能用左移的方式得到最终的指数和有效数吗？）。把它用浮点数的各部分表示：
  - sign: 0，指数：-2 + 127 ，为 `0111 1101`，有效数：为 `01` 填充满 23 位，为 `0101 0101 0101 0101 0101 010`
  - 合起来是：`0 | 0111 1101 | 0101 0101 0101 0101 0101 010`

我们有两种方式来理解二进制有效位表示的值，首先可用十进制进行类比：
- 0.340<sub>10</sub>
  - = 340 / 1000
  - =34 / 100
- 0.110<sub>2</sub>, 二进制 0.110，等于二进制110除以二进制的1000，等于二进制的11除以二进制的100
  - = 110 / 1000<sub>2</sub> => (十进制) 6 / 8
  - = 11 / 100<sub>2</sub> => (十进制) 3 / 4

这种方式简便明了。

其次可计算各二进制有效位的值，同样用十进制类比：
- 十进制：1.6732 = 1×10^0 + 6×10(-1) + 7×10(-2) + 3×10(-3) + 2×10(-4)
- 二进制：1.1001 = 1×2^0 + 1×2^(-1) + 0×2^(-2) + 0×2^(-3) + 1×2^(-4)

常用这种方式来将计算浮点数表示的值。

浮点数的几个的性质：

1. 不符合加法交换律：浮点数不符合加法交换律。因为浮点数表示的都是实际值的近似值。

如：x = -1.5×10^38, y = 1.5×10^38, z = 1.0;
x+(y+z) = -1.5×10^38 + (1.5×10^38 + 1.0) = -1.5×10^38 + (1.5×10^38) = 0;
(x+y)+z = (-1.5×10^38 + 1.5×10^38) + 1.0 = 0.0 + 1.0 = 1.0;

例子中 1.5×10^38 比 1.0 大了太多，以至于 1.5×10^38 + 1.0 在浮点数中的表示仍然是 1.5×10^38

2. 精度（precision）和准确度（accuracy）

精度：由有效数的位数决定，是说我们用多少有效位的 bits 去表示一个值，单精度用 32 位、双精度用 64 位表示一个浮点数。
准确度：指一个实际的值和它用计算机表示后的值，之间差多少。浮点数离 0 越近，准确度越高，离 0 约远（表示的数越大），准确度约低。

高精度允许得到较高准确度，但不保证。

如，`float pi = 3.14`，pi 会用到 24 位来表示它的有效位（高精度），但这个仍只是近似值，不是准确的pi值。

3. 舍入

当在计算上进行浮点数数学计算时，有时这个值不能落到某个浮点数上（因为浮点数其实是一系列离散的值，之间最小的间隔是 2^(-149)），硬件就要确定是用下一个浮点数值，还是上一个浮点数值，这就发生了舍入。

舍入也会在以下情况下发生：
  - 将双精度转为单精度值时；
  - 将浮点数转为一个整型时；

浮点数硬件往往有多出来几位（如2-3bits）作为 rounding area，落到这个区域里的bits需要被舍入。

IEEE 浮点数有四种舍入的模式（以下用十进制举例）：
  - 向正无穷舍入：
    - 总是向更大的值舍入，2.001 -> 3, -2.001 -> -2
  - 向负无穷舍入：
    - 总是向更小的值舍入，1.999 -> 1, -1.999 -> -2
  - 截断
    - 扔掉 rounding area 的位数，又叫向 0 舍入
  - unbiased（默认模式），类似四折五入，遇到正中间，向偶数舍入
    - 如，2.4 -> 2, 2.6 -> 3, 2.5 -> 2, 3.5 -> 4

二进制中的情形如：`0101 | 100`，| 后面是 3 位的 rounding area，100 表示是中间的值（类似十进制的 0.5），舍入的规则是，向偶数舍入，将 `0101` 舍入后变为 `0110`

浮点数的加法：
  - 两个浮点数相加，先统一指数部分
  - 将有效数相加，保持相同的指数
  - 再 normalize（有可能改变指数）

浮点数转整型：C 会截去小数点部分，`i = (int) (3.14159 * f)`
整型转浮点数：取最近的浮点数。
`int => float => int`: 得到的值和原始整型一样吗？ 不一定。大多数大数值整型没有对应的浮点数表示，都得用近似值表示。

比如 2^23(16777216)能用浮点数表示，但给它有效位加1后，其表示的数直接变成了16777218，也就是 16777217 没有对应的浮点数表示！

## 6.5 - Floating Point: 其他浮点数

最后，浮点数为什么叫浮点（浮动的小数点），是因为其计算时，小数点在哪里会随着指数左右浮动！。

其他浮点数：
double: 64位，从左到右
  - 1位符号
  - 11位指数
  - 52位有效数
能表示的最小正值 2.0×10^(-308)，最大正值 2.0×10^(308)，由于有效数位数大，表示数值的准确度也高。

也有更小的 16位，更大的128位/256位 来保存浮点数的。

使用更大位数的指数位，表示数的范围会扩大，
使用更大位数的有效数位，精度上升，表示数的准确度会更大

IEEE fp16: 1位符号位，5位指数位，10位有效数位
Google 的 TPU v2, v3 使用 bfloat16 用于机器学习：1位符号位，8位指数位，7位有效数位
Nvidia Ampere TensorCore 用了 tf32: 1位符号位，8位指数位，10位有效数位，共32位，但用了19位，功耗小
Huawei Da Vinci: 支持 int8 和 fp16
Tesla NPU: 支持 int8