# week2: C 语言入门

## lecture 3：基础类型，操作符，C 语言与 Java 的区别

## lecture 4：指针与数组

## lecture 5：内存管理：栈内存、堆内存的管理

#c的内存种类
C语言的内存分三块：
  1. stack：栈，在函数内声明的变量，都在栈中。函数返回后，其占用的内存失效。实际上是栈指针上移（栈空间往下扩展），使得当前的栈帧不再可用，但变量还在内存中。
  2. heap： 堆，动态获取你空间都位于堆中，堆往上扩展；
  3. 静态存储，static storage，全局变量位于静态存储，程序运行期间一直存在，大小不变。

使用变量时要知道该变量存放在哪一部分。

#内存地址空间
之前一直有疑问，32位的内存寻址空间跟内存最大支持4G有什么关系。

地址空间是相当于一系列编号，32位寻址空间有2^32个编号（从十六位的 0000 0000 到 FFFF FFFF），但每个编号可以存多少数据还不知道呢，怎么推导出最大支持4G呢？

那不知道的部分是：计算机cpu**按字节寻址**，即从 0000 0000 这个地址到 0000 0001 这个地址，保存的数据是1个字节。那么（2^32）个编号保存的数据是（2^32）个字节，也就是 4G

#The_Stack
调用函数就在栈中创建一个栈帧（stack frame），栈帧有以下信息：
  1. 返回指令的地址，用以记录上一个执行的栈
  2. 参数
  3. 其他本地变量的空间

栈指针（stack pointer）指向栈中的顶层栈帧。

#The_Heap
- 每个内存块（memory block）都包含一个头部部分，里面有两个字段：内存块大小以及下一个内存块的指针。
- 所有的可用内存块（free block）都保存在一个循环链表中，调用 malloc() 会遍历可用内存链表，寻找足够大小的空间，如果没有，则向操作系统申请更多内存，如果申请到的内存不满足要求，则调用失败。free() 会检查被释放的内存块的相邻块是否空闲，是则将这些空闲块合并为一块大的可用内存块。
- malloc() 有三种策略寻找合适的空间：
	- First fit：返回第一个合适的；
	- Next fit：类似 First，但从上一次查找的地方开始；
	- Best fit: 从整个可用空闲链表中寻找最合适的返回；
	
#内存管理的注意事项
malloc
	- 获取动态内存后，要先初始化，再使用；
	- 动态内存使用后要记得free
	- malloc 出来的那些内存地址，内部都会记录，在free() 时要传入malloc返回的内存地址
栈内存
	- 不要返回在栈内存中创建的本地变量的指针，因为它的空间是在栈上获取的，栈帧一旦返回，对应的空间就会被后续函数调用创建的栈帧覆盖